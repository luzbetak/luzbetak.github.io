function replyOneDay() {
  // === CONFIG ===
  const DRY_RUN = false;                 // set to true to test without sending
  const MAX_SEND = 50;                   // safety cap per run
  const QUERY = '(Torrance OR Irvine) -in:chats -in:drafts -in:spam -in:trash newer_than:365d';
  const PROCESSED_LABEL = 'AutoReplied/SoCalCityFilter';
  const SLEEP_MS = 150;                  // tiny pause between sends

  // Engines / job boards to never reply to
  const BLOCKED_DOMAIN_RE = /\b(indeed\.com|linkedin\.com|dice\.com)\b/i;

  // Cities to detect (add more as needed)
  const CITIES = [
    { name: 'Torrance', re: /\btorrance\b/i },
    { name: 'Irvine',   re: /\birvine\b/i }
  ];

  // Single dynamic reply (city inserted at runtime)
  const makeCityReply = (city) => `
I'm based in Agoura Hills, California, and can only be on-site in ${city} one day per week due to the commute distance and time. My minimum salary requirement is $90/hour (approximately $187K per year).

Please share the job ID, client, location, rate, and interview process.

Thanks,
Kevin Luzbetak
(747) 388-0422`.trim();

  // Fallback reply if a city was not identified, but the thread matched the search
  const DEFAULT_REPLY = `
I'm based in Agoura Hills, California. For on-site roles outside my local area, I can be on-site up to one day per week due to the commute distance and time. My minimum salary requirement is $90/hour (approximately $187K per year).

Please share the job ID, client, location, rate, and interview process.

Thanks,
Kevin Luzbetak
(747) 388-0422`.trim();

  // === SETUP ===
  const me = Session.getActiveUser().getEmail().toLowerCase();
  let label = GmailApp.getUserLabelByName(PROCESSED_LABEL);
  if (!label) label = GmailApp.createLabel(PROCESSED_LABEL);

  // Avoid reprocessing threads already labeled
  const threads = GmailApp.search(`${QUERY} -label:"${PROCESSED_LABEL}"`, 0, 500);

  // === LOG HEADER ===
  console.log(`Found ${threads.length} matching threads. DRY_RUN=${DRY_RUN}, MAX_SEND=${MAX_SEND}`);
  console.log(`Query: ${QUERY}`);

  let sent = 0, considered = 0, skipped = 0, errors = 0;

  for (const thread of threads) {
    if (!DRY_RUN && sent >= MAX_SEND) {
      console.log(`Reached MAX_SEND (${MAX_SEND}). Stopping.`);
      break;
    }

    const msgs = thread.getMessages();
    const last = msgs[msgs.length - 1];
    considered++;

    // Skip if last message is from me
    const fromStr = (last.getFrom() || '').toLowerCase();
    if (fromStr.includes(me)) {
      skipped++;
      console.log(`Skip (last from me): ${last.getSubject()}`);
      continue;
    }

    // Skip common noreply patterns
    if (/(noreply|no-reply|donotreply)/i.test(fromStr)) {
      skipped++;
      console.log(`Skip (noreply): ${fromStr} | ${last.getSubject()}`);
      continue;
    }

    // Block engines/job boards by domain in From or Reply-To
    let replyToStr = '';
    try { replyToStr = (last.getReplyTo() || '').toLowerCase(); } catch (e) {}
    const headerAddrBlob = `${fromStr} ${replyToStr}`;
    if (BLOCKED_DOMAIN_RE.test(headerAddrBlob)) {
      skipped++;
      console.log(`Skip (blocked engine domain): ${headerAddrBlob} | ${last.getSubject()}`);
      continue;
    }

    // Heuristics for lists/bulk/autogenerated mail
    try {
      const autoSubmitted = (last.getHeader && last.getHeader('Auto-Submitted')) || '';
      const precedence   = (last.getHeader && last.getHeader('Precedence')) || '';
      const listId       = (last.getHeader && last.getHeader('List-Id')) || '';
      if ((autoSubmitted && autoSubmitted.toLowerCase() !== 'no') ||
          /bulk|list|junk/i.test(precedence) ||
          (listId && listId.length > 0)) {
        skipped++;
        console.log(`Skip (bulk/list): ${fromStr} | ${last.getSubject()}`);
        continue;
      }
    } catch (e) { /* header access may not be available */ }

    // Determine which city is mentioned (subject/body)
    const subject = last.getSubject() || '';
    let body = '';
    try { body = (last.getPlainBody() || '').slice(0, 3000); } catch (e) { body = ''; }
    const haystack = `${subject}\n${body}`;

    // Find the *first* city that appears in the text (by earliest index)
    let matchedCity = null;
    let bestIdx = Infinity;
    for (const c of CITIES) {
      const m = haystack.match(c.re);
      if (m && m.index < bestIdx) {
        bestIdx = m.index;
        matchedCity = c.name;
      }
    }

    const replyText = matchedCity ? makeCityReply(matchedCity) : DEFAULT_REPLY;

    try {
      if (DRY_RUN) {
        thread.addLabel(label);
        console.log(`WOULD reply (${matchedCity || 'default'}) -> ${fromStr} | "${subject}"`);
      } else {
        last.reply(replyText);           // reply to the sender of the last message
        thread.addLabel(label);          // mark processed to avoid double replies
        sent++;
        console.log(`Replied (${matchedCity || 'default'}) -> ${fromStr} | "${subject}"`);
        Utilities.sleep(SLEEP_MS);
      }
    } catch (err) {
      errors++;
      console.log(`ERROR on "${thread.getFirstMessageSubject()}": ${err}`);
    }
  }

  // === SUMMARY ===
  console.log(`Summary -> Considered: ${considered}, Sent: ${sent}, Skipped: ${skipped}, Errors: ${errors}`);
}

