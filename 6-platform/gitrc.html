---
---
{% include menu.html title="gitrc" %}
<hr align=left width=1000>

<h2>Create the next branch</h2>
<pre><code class=language-bash>#----------------------------------------------------------------------------#
function next() {
    # Get the latest branch with the format v0.xx
    latest_branch=$(git branch --all --sort=-committerdate | grep -E 'v[0-9]+\.[0-9]+' | sort -r | head -n 1 | sed 's/.*\///')

    # Extract the numeric part and increment it
    if [[ $latest_branch =~ ^v([0-9]+)\.([0-9]+)$ ]]; then
        major=${BASH_REMATCH[1]}
        minor=${BASH_REMATCH[2]}
        new_minor=$(printf "%02d" $((10#$minor + 1)))
        new_branch="v$major.$new_minor"

        # Create the new branch if it doesn't already exist
        if git rev-parse --verify $new_branch >/dev/null 2>&1; then
            echo "Branch $new_branch already exists. Incrementing further."
            next
        else
            git checkout -b $new_branch
            echo "New branch created: $new_branch"
        fi
    else
        # If no valid branch is found, create the first branch
        new_branch="v0.01"
        while git rev-parse --verify $new_branch >/dev/null 2>&1; do
            major=$(echo $new_branch | cut -d '.' -f 1 | sed 's/v//')
            minor=$(echo $new_branch | cut -d '.' -f 2)
            new_minor=$(printf "%02d" $((10#$minor + 1)))
            new_branch="v$major.$new_minor"
        done
        git checkout -b $new_branch
        echo "Created new branch: $new_branch"
    fi
}
#-------------------------------------------------------------------------------------------#
get() {
    # Fetch the latest branches from the remote
    git fetch

    # Find the latest branch in the format 'vx.xx'
    latest_branch=$(git branch -r | grep -o 'origin/v[0-9]\+\.[0-9]\+' | sort -V | tail -n 1)

    if [ -z "$latest_branch" ]; then
        echo "No versioned branch (vx.xx) found in remote branches."
        return 1
    fi

    # Extract the branch name without 'origin/'
    latest_branch_name=${latest_branch#origin/}

    # Stash any local changes
    git stash

    # Check out the latest version branch
    git checkout "$latest_branch_name"
    echo "Checked out latest version branch: $latest_branch_name"
}
#-------------------------------------------------------------------------------------------#
com () {
    # Get the current branch name
    BRANCH=$(git branch --show-current)

    # Stage all changes
    git add --all -v .

    # Commit with a custom message if provided, or use the current date/time as the message
    if [ "$1" ]; then
        # Join all arguments with spaces to create the full commit message
        commit_message="$*"
        git commit -m "${commit_message}"
    else
        DATE=$(date "+%Y-%m-%d %H:%M")
        git commit -m "${DATE}"
    fi

    # Check if the branch has an upstream
    UPSTREAM=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)

    # If no upstream is set, push and set upstream to origin/BRANCH
    if [ -z "$UPSTREAM" ]; then
        echo "Setting upstream for branch $BRANCH to origin/$BRANCH"
        git push --set-upstream origin "$BRANCH"
    else
        # If upstream is set, just push to the remote
        git push origin "$BRANCH"
    fi
}
#-------------------------------------------------------------------------------------------#
</code></pre>
{% include footer.html %}

