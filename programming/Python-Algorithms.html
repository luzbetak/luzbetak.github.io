---
---
{% include menu.html title="Python Algorithms" %}


<h1>Python Algorithms</h1>

<p><hr align=left width=1000>
<h2>Reverse a String</h2>
<pre><code class="language-python">def reverse_string(s: str) -> str:
        return s[::-1]
    
print(reverse_string("hello"))  # Output: "olleh"
</code></pre>

<p><hr align=left width=1000>
<h2>Find the Largest Number in a List</h2>
<pre><code class="language-python">def find_largest(nums: list) -> int:
        return max(nums)
    
    print(find_largest([1, 2, 3, 4, 5]))  # Output: 5
</code></pre>

<p><hr align=left width=1000>
<h2>Two Sum Problem</h2>
This Python function two_sum is designed to solve the "two-sum" problem. The problem is to find two numbers in a list (nums) that add up to a specific target value (target). The function returns the indices of these two numbers in the list.
<pre><code class="language-python">def two_sum(nums: list, target: int) -> list:
    num_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], i]
        num_map[num] = i

print(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]
</code></pre>


<p><hr align=left width=1000>
<h2>Remove Duplicates from a List</h2>
<pre><code class="language-python">def remove_duplicates(nums: list) -> list:
    return list(set(nums))
    
print(remove_duplicates([1, 2, 2, 3, 4, 4, 5]))  # Output: [1, 2, 3, 4, 5]
</code></pre>


<p><hr align=left width=1000>
<h2>Count the Number of Vowels in a String</h2>
<pre><code class="language-python">def count_vowels(s: str) -> int:
    vowels = 'aeiouAEIOU'
    return sum(1 for char in s if char in vowels)
    
 print(count_vowels("hello world"))  # Output: 3
</code></pre>


<p><hr align=left width=1000>
<h2>Merge Two Sorted Lists</h2>
<pre><code class="language-python">def merge_sorted_lists(list1: list, list2: list) -> list:
    merged = []
    i = j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            merged.append(list1[i])
            i += 1
        else:
            merged.append(list2[j])
            j += 1
    merged.extend(list1[i:])
    merged.extend(list2[j:])
    return merged

print(merge_sorted_lists([1, 3, 5], [2, 4, 6]))  # Output: [1, 2, 3, 4, 5, 6]
</code></pre>

<p><hr align=left width=1000>
<h2>Find the First Non-Repeated Character in a String</h2>
<pre><code class="language-python">def first_non_repeated_char(s: str) -> str:
    counts = {}
    for char in s:
        counts[char] = counts.get(char, 0) + 1
    for char in s:
        if counts[char] == 1:
            return char
    return None
print(first_non_repeated_char("swiss"))  # Output: "w"
</code></pre>

<p><h2>Find the Intersection of Two Lists</h2>
<pre><code class="language-python">def list_intersection(list1: list, list2: list) -> list:
    return list(set(list1) & set(list2))

print(list_intersection([1, 2, 3, 4], [3, 4, 5, 6]))  # Output: [3, 4]
</code></pre>


<p><hr align=left width=1000>
<h2>Binary Search</h2>
The binary search algorithm works by repeatedly dividing the array into two halves until the target element is found or a single element remains. In each iteration, we compare the middle element of the current half with the target element. If they are equal, we return the index of the middle element as the result. If the middle element is less than the target element, we discard the first half of the array and repeat the same process on the second half. Similarly, if the middle element is greater than the target element, we discard the second half of the array and repeat the same process on the first half.
<pre><code class="language-python">def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
</code></pre>

<p><hr align=left width=1000>
<h2>Two Sum</h2>
The two sum algorithm works by iterating through the array and for each element, finding its complement (i.e., the other number that adds up to the target value). We use a nested loop to iterate through the remaining elements of the array and check if their sum is equal to the target value. If it is, we return the indices of both elements as the result.
<pre><code class="language-python">def two_sum(arr, target):
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if arr[i] + arr[j] == target:
                return [i, j]
    return [-1, -1]
</code></pre>

<p><hr align=left width=1000>
<h2>Longest Common Subsequence</h2>
The longest common subsequence algorithm works by defining a dynamic programming array dp of size m x n, where m is the length of string str1 and n is the length of string str2. We initialize all elements of dp to 0. Then, for each element in str1, we iterate through all elements in str2 and check if they are equal. If they are equal, we set the value of dp[i][j] to 1 + the value of dp[i-1][j-1]. Otherwise, we compare the values of dp[i-1][j] and dp[i][j-1] and take the maximum value. Finally, we return the last element of the last row of dp as the result.
<pre><code class="language-python">def longest_common_subsequence(str1, str2):
    m = len(str1) + 1
    n = len(str2) + 1
    dp = [[0] * (n) for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[-1][-1]
</code></pre>

<p><hr align=left width=1000>
<h2>Merge Sort</h2>
The merge sort algorithm works by dividing the array into two halves, sorting each half recursively and then merging them back together. In the base case, an array of length 1 or less is considered sorted and returned as is.
<pre><code class="language-python">def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    while left and right:
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    if left:
        result += left
    if right:
        result += right
    return result
</code></pre>

<p><hr align=left width=1000>
<h2>Quick Sort</h2>
<pre><code class="language-python">def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = [x for x in arr[1:] if x <= pivot]
    right = [x for x in arr[1:] if x > pivot]
    return quick_sort(left) + [pivot] + quick_sort(right)
</code></pre>
<p>The quick sort algorithm works by selecting a pivot element from the array and partitioning it into two halves, one containing elements less than or equal to the pivot and another containing elements greater than the pivot. We then recursively call the quick sort function on both halves.</p>

<p><hr align=left width=1000>
<h2>Fibonacci Series</h2>
The Fibonacci series algorithm works by defining a recursive function that takes an integer argument n. If n is 0 or 1, we return the value of n as the result. Otherwise, we add the values of fibonacci(n-1) and fibonacci(n-2).
<pre><code class="language-python">def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)
print(fibonacci(5)) # 5           
</code></pre>

<p><hr align=left width=1000>
<h2>Palindrome Check</h2>
The palindrome check algorithm works by returning a boolean value indicating whether the string is a palindrome or not. We use slicing to access the characters of the string in reverse order and compare it with the original string.
<pre><code class="language-python">def is_palindrome(str):
        return str == str[::-1]
    
    print(is_palindrome("121"))  # True
    print(is_palindrome("122"))  # False
</code></pre>

<p><hr align=left width=1000>
<h2>Anagram</h2>
The anagram algorithm works by sorting both strings and comparing them lexicographically. If they are equal, we return True; otherwise, we return False.
<pre>
def anagram(str1, str2):
    return sorted(str1) == sorted(str2)
</code></pre>

<p><hr align=left width=1000>
<h2>FizzBuzz</h2>
The FizzBuzz algorithm works by defining a function that takes an integer argument n. If n is divisible by 3, we return the string "Fizz". If n is divisible by 5, we return the string "Buzz". Otherwise, we return the string representation of n.
<pre><code class="language-python">def fizzbuzz(n):
    if n % 3 == 0:
        return "Fizz"
    elif n % 5 == 0:
        return "Buzz"
    else:
        return str(n)
</code></pre>

<p><hr align=left width=1000>
<h2>Longest Common Subsequence</h2>
The longest common subsequence algorithm works by defining a dynamic programming array dp of size m x n, where m is the length of string str1 and n is the length of string str2. We initialize all elements of dp to 0. Then, for each element in str1, we iterate through all elements in str2 and check if they are equal. If they are equal, we set the value of dp[i][j] to 1 + the value of dp[i-1][j-1]. Otherwise, we compare the values of dp[i-1][j] and dp[i][j-1] and take the maximum value. Finally, we return the last element of the last row of dp as the result.
<pre><code class="language-python">def longest_common_subsequence(str1, str2):
    dp = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)]
    for i in range(1, len(str1) + 1):
        for j in range(1, len(str2) + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
</code></pre>

<p><hr align=left width=1000>
<h2>Hamming distance between two strings</h2>
<pre><code class="language-python">import math
from collections import Counter
import numpy as np

def hamming_distance(str1, str2):
    """Calculate the Hamming distance between two strings.

    Args:
        str1 (string): The first string for comparison.
        str2 (string): The second string for comparison.

    Returns:
        int: The Hamming distance between the two strings.
    """
    # Convert both strings to lowercase
    str1 = str1.lower()
    str2 = str2.lower()

    # Calculate the Hamming distance by comparing each character in the two strings
    distance = 0
    for c1, c2 in zip(str1, str2):
        if c1 != c2:
            distance += 1

    return distance
</code></pre>

<p><hr align=left width=1000>
<h2>Levenshtein distance between two strings</h2>
<pre><code class="language-python">def levenshtein_distance(str1, str2):
    """Calculate the Levenshtein distance between two strings.

    Args:
        str1 (string): The first string for comparison.
        str2 (string): The second string for comparison.
    
    Returns: 
        int: The Levenshtein distance between the two strings.
    """
    # Calculate the number of insertions, deletions, and substitutions needed to transform str1 into str2
    # using dynamic programming
    m = len(str1) + 1
    n = len(str2) + 1
    dp = np.zeros((m, n))
    for i in range(1, m):
        for j in range(1, n):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j] + 1, dp[i][j-1] + 1)
            else:
                dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1)

    return dp[-1][-1]
</code></pre>

  {% include footer.html %}

  </body>
</html>
